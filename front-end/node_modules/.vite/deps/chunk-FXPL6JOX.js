import {
  require_LexicalSelection
} from "./chunk-WV74K6YI.js";
import {
  require_Lexical
} from "./chunk-JO4QXUCP.js";
import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// ../node_modules/@lexical/utils/LexicalUtils.dev.js
var require_LexicalUtils_dev = __commonJS({
  "../node_modules/@lexical/utils/LexicalUtils.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function addClassNamesToElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          const classesToAdd = className.split(" ").filter((n) => n !== "");
          element.classList.add(...classesToAdd);
        }
      });
    }
    function removeClassNamesFromElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          element.classList.remove(...className.split(" "));
        }
      });
    }
    function isMimeType(file, acceptableMimeTypes) {
      for (const acceptableType of acceptableMimeTypes) {
        if (file.type.startsWith(acceptableType)) {
          return true;
        }
      }
      return false;
    }
    function mediaFileReader(files, acceptableMimeTypes) {
      const filesIterator = files[Symbol.iterator]();
      return new Promise((resolve, reject) => {
        const processed = [];
        const handleNextFile = () => {
          const {
            done,
            value: file
          } = filesIterator.next();
          if (done) {
            return resolve(processed);
          }
          const fileReader = new FileReader();
          fileReader.addEventListener("error", reject);
          fileReader.addEventListener("load", () => {
            const result = fileReader.result;
            if (typeof result === "string") {
              processed.push({
                file,
                result
              });
            }
            handleNextFile();
          });
          if (isMimeType(file, acceptableMimeTypes)) {
            fileReader.readAsDataURL(file);
          } else {
            handleNextFile();
          }
        };
        handleNextFile();
      });
    }
    function $dfs(startingNode, endingNode) {
      const nodes = [];
      const start = (startingNode || lexical.$getRoot()).getLatest();
      const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
      let node = start;
      let depth = $getDepth(node);
      while (node !== null && !node.is(end)) {
        nodes.push({
          depth,
          node
        });
        if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
          node = node.getFirstChild();
          depth++;
        } else {
          let sibling = null;
          while (sibling === null && node !== null) {
            sibling = node.getNextSibling();
            if (sibling === null) {
              node = node.getParent();
              depth--;
            } else {
              node = sibling;
            }
          }
        }
      }
      if (node !== null && node.is(end)) {
        nodes.push({
          depth,
          node
        });
      }
      return nodes;
    }
    function $getDepth(node) {
      let innerNode = node;
      let depth = 0;
      while ((innerNode = innerNode.getParent()) !== null) {
        depth++;
      }
      return depth;
    }
    function $getNearestNodeOfType(node, klass) {
      let parent = node;
      while (parent != null) {
        if (parent instanceof klass) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    function $getNearestBlockElementAncestorOrThrow(startNode) {
      const blockNode = $findMatchingParent(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
      if (!lexical.$isElementNode(blockNode)) {
        {
          throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
        }
      }
      return blockNode;
    }
    function $findMatchingParent(startingNode, findFn) {
      let curr = startingNode;
      while (curr !== lexical.$getRoot() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    }
    function mergeRegister(...func) {
      return () => {
        func.forEach((f) => f());
      };
    }
    function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
      const $isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const $findMatch = (node) => {
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if ($isTargetNode(child)) {
            return null;
          }
        }
        let parentNode = node;
        let childNode = node;
        while (parentNode !== null) {
          childNode = parentNode;
          parentNode = parentNode.getParent();
          if ($isTargetNode(parentNode)) {
            return {
              child: childNode,
              parent: parentNode
            };
          }
        }
        return null;
      };
      const elementNodeTransform = (node) => {
        const match = $findMatch(node);
        if (match !== null) {
          const {
            child,
            parent
          } = match;
          if (child.is(node)) {
            handleOverlap(parent, node);
            const nextSiblings = child.getNextSiblings();
            const nextSiblingsLength = nextSiblings.length;
            parent.insertAfter(child);
            if (nextSiblingsLength !== 0) {
              const newParent = cloneNode(parent);
              child.insertAfter(newParent);
              for (let i = 0; i < nextSiblingsLength; i++) {
                newParent.append(nextSiblings[i]);
              }
            }
            if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
              parent.remove();
            }
          }
        }
      };
      return editor.registerNodeTransform(targetNode, elementNodeTransform);
    }
    function $restoreEditorState(editor, editorState) {
      const FULL_RECONCILE = 2;
      const nodeMap = /* @__PURE__ */ new Map();
      const activeEditorState = editor._pendingEditorState;
      for (const [key, node] of editorState._nodeMap) {
        const clone = selection.$cloneWithProperties(node);
        if (lexical.$isTextNode(clone)) {
          clone.__text = node.__text;
        }
        nodeMap.set(key, clone);
      }
      if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
      }
      editor._dirtyType = FULL_RECONCILE;
      const selection$1 = editorState._selection;
      lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
    }
    function $insertNodeToNearestRoot(node) {
      const selection2 = lexical.$getSelection() || lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(selection2)) {
        const {
          focus
        } = selection2;
        const focusNode = focus.getNode();
        const focusOffset = focus.offset;
        if (lexical.$isRootOrShadowRoot(focusNode)) {
          const focusChild = focusNode.getChildAtIndex(focusOffset);
          if (focusChild == null) {
            focusNode.append(node);
          } else {
            focusChild.insertBefore(node);
          }
          node.selectNext();
        } else {
          let splitNode;
          let splitOffset;
          if (lexical.$isTextNode(focusNode)) {
            splitNode = focusNode.getParentOrThrow();
            splitOffset = focusNode.getIndexWithinParent();
            if (focusOffset > 0) {
              splitOffset += 1;
              focusNode.splitText(focusOffset);
            }
          } else {
            splitNode = focusNode;
            splitOffset = focusOffset;
          }
          const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
          rightTree.insertBefore(node);
          rightTree.selectStart();
        }
      } else {
        if (lexical.$isNodeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
          const nodes = selection2.getNodes();
          nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
        } else {
          const root = lexical.$getRoot();
          root.append(node);
        }
        const paragraphNode = lexical.$createParagraphNode();
        node.insertAfter(paragraphNode);
        paragraphNode.select();
      }
      return node.getLatest();
    }
    function $wrapNodeInElement(node, createElementNode) {
      const elementNode = createElementNode();
      node.replace(elementNode);
      elementNode.append(node);
      return elementNode;
    }
    function objectKlassEquals(object, objectClass) {
      return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
    }
    function $filter(nodes, filterFn) {
      const result = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = filterFn(nodes[i]);
        if (node !== null) {
          result.push(node);
        }
      }
      return result;
    }
    function $insertFirst(parent, node) {
      const firstChild = parent.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(node);
      } else {
        parent.append(node);
      }
    }
    exports.$splitNode = lexical.$splitNode;
    exports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;
    exports.isHTMLElement = lexical.isHTMLElement;
    exports.$dfs = $dfs;
    exports.$filter = $filter;
    exports.$findMatchingParent = $findMatchingParent;
    exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    exports.$getNearestNodeOfType = $getNearestNodeOfType;
    exports.$insertFirst = $insertFirst;
    exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;
    exports.$restoreEditorState = $restoreEditorState;
    exports.$wrapNodeInElement = $wrapNodeInElement;
    exports.addClassNamesToElement = addClassNamesToElement;
    exports.isMimeType = isMimeType;
    exports.mediaFileReader = mediaFileReader;
    exports.mergeRegister = mergeRegister;
    exports.objectKlassEquals = objectKlassEquals;
    exports.registerNestedElementResolver = registerNestedElementResolver;
    exports.removeClassNamesFromElement = removeClassNamesFromElement;
  }
});

// ../node_modules/@lexical/utils/LexicalUtils.js
var require_LexicalUtils = __commonJS({
  "../node_modules/@lexical/utils/LexicalUtils.js"(exports, module) {
    var LexicalUtils = true ? require_LexicalUtils_dev() : null;
    module.exports = LexicalUtils;
  }
});

export {
  require_LexicalUtils
};
//# sourceMappingURL=chunk-FXPL6JOX.js.map
