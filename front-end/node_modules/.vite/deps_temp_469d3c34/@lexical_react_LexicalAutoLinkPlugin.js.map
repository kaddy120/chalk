{
  "version": 3,
  "sources": ["../../../../node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.js", "../../../../node_modules/@lexical/react/LexicalAutoLinkPlugin.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) return null;\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(text)\n    };\n  };\n}\n\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n\n    if (match) {\n      return match;\n    }\n  }\n\n  return null;\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\n\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\n\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\n\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n\n  if (lexical.$isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n\n  return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\n\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n\n  if (lexical.$isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n\n  return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\n\nfunction isContentAroundIsValid(matchStart, matchEnd, text, node) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(node);\n\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(node);\n  return contentAfterIsValid;\n}\n\nfunction handleLinkCreation(node, matchers, onChange) {\n  const nodeText = node.getTextContent();\n  let text = nodeText;\n  let invalidMatchEnd = 0;\n  let remainingTextNode = node;\n  let match;\n\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, nodeText, node);\n\n    if (isValid) {\n      let linkTextNode;\n\n      if (invalidMatchEnd + matchStart === 0) {\n        [linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchLength);\n      } else {\n        [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchStart, invalidMatchEnd + matchStart + matchLength);\n      }\n\n      const linkNode = link.$createAutoLinkNode(match.url, match.attributes);\n      const textNode = lexical.$createTextNode(match.text);\n      textNode.setFormat(linkTextNode.getFormat());\n      textNode.setDetail(linkTextNode.getDetail());\n      linkNode.append(textNode);\n      linkTextNode.replace(linkNode);\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n\n    text = text.substring(matchEnd);\n  }\n}\n\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n\n    if (!lexical.$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  } // Check text content fully matches\n\n\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  } // Check neighbors\n\n\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  const url = linkNode.getURL();\n\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n\n    const target = linkNode.getTarget();\n\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n} // Bad neighbours are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\n\n\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n\n  if (link.$isAutoLinkNode(previousSibling) && !startsWithSeparator(text)) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n\n  if (link.$isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\n\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n\n  node.remove();\n  return children.map(child => child.getLatest());\n}\n\nfunction useAutoLink(editor, matchers, onChange) {\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n\n    return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n\n      if (link.$isAutoLinkNode(parent)) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!link.$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !link.$isAutoLinkNode(previous))) {\n          handleLinkCreation(textNode, matchers, onChangeWrapped);\n        }\n\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }));\n  }, [editor, matchers, onChange]);\n}\n\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexports.AutoLinkPlugin = AutoLinkPlugin;\nexports.createLinkMatcherWithRegExp = createLinkMatcherWithRegExp;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalAutoLinkPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalAutoLinkPlugin.dev.js') : require('./LexicalAutoLinkPlugin.prod.js')\nmodule.exports = LexicalAutoLinkPlugin;"],
  "mappings": "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",
  "names": []
}
